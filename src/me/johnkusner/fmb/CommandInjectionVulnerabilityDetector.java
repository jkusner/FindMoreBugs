package me.jkush321.fmb;

import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InvokeInstruction;
import org.apache.bcel.generic.MethodGen;

import edu.umd.cs.findbugs.BugAccumulator;
import edu.umd.cs.findbugs.BugInstance;
import edu.umd.cs.findbugs.BugReporter;
import edu.umd.cs.findbugs.Detector;
import edu.umd.cs.findbugs.SourceLineAnnotation;
import edu.umd.cs.findbugs.ba.CFG;
import edu.umd.cs.findbugs.ba.CFGBuilderException;
import edu.umd.cs.findbugs.ba.ClassContext;
import edu.umd.cs.findbugs.ba.DataflowAnalysisException;
import edu.umd.cs.findbugs.ba.Location;
import edu.umd.cs.findbugs.ba.constant.Constant;
import edu.umd.cs.findbugs.ba.constant.ConstantDataflow;
import edu.umd.cs.findbugs.ba.constant.ConstantFrame;
import edu.umd.cs.findbugs.classfile.MethodDescriptor;

public class CommandInjectionVulnerabilityDetector implements Detector {
	private BugAccumulator bugAccumulator;

	// List of function calls with params and returns that is being looked for
	// Equivalent of MethodDescriptor.toString()
	List<String> methodsToWatch = Arrays.asList(new String[]{
			"static java.lang.Class.forName(Ljava/lang/String;)Ljava/lang/Class;",
			"java.lang.Runtime.exec(Ljava/lang/String;)Ljava/lang/Process;"
	});
	
	public CommandInjectionVulnerabilityDetector(BugReporter bugReporter)
	{
		this.bugAccumulator = new BugAccumulator(bugReporter);
	}
	
	// Called when detector visits class,
	// This is what will call analyzeMethod
	public void visitClassContext(ClassContext cc) {
		JavaClass jc = cc.getJavaClass();
		
		Method[] methods = jc.getMethods();
		
		for (Method m : methods) {
			MethodGen mg = cc.getMethodGen(m);
			
			if (mg == null) {
				continue;
			}
			
			try {
				analyzeMethod(cc, m);
			} catch (Exception e) {
				// There was a problem,
				// report it. Probably
				// isn't going to
				// be a big deal.
				e.printStackTrace();
			}
		}
	}
	
	// Analyzes method calls looking for Runtime.exec and Class.forName
	// Checks for non-constant strings
	private void analyzeMethod(ClassContext cc, Method m) throws CFGBuilderException, DataflowAnalysisException {
		JavaClass jc = cc.getJavaClass();
		
		MethodGen mg = cc.getMethodGen(m);
		
		if (mg == null) {
			return;
		}
		
		ConstantPoolGen cpg = mg.getConstantPool();
		CFG cfg = cc.getCFG(m);
		
		ConstantDataflow df = cc.getConstantDataflow(m);
		
		for (Iterator<Location> i = cfg.locationIterator(); i.hasNext();) {
			Location l = i.next();
			Instruction ins = l.getHandle().getInstruction();
			if (!(ins instanceof InvokeInstruction)) {
				continue;
			}
			InvokeInstruction ii = (InvokeInstruction) ins;
			MethodDescriptor md = new MethodDescriptor(ii, cpg);
			
			// Skip this method if it's not on the list
			if (!methodsToWatch.contains(md.toString()))
			{
				continue;
			}
			
			ConstantFrame cf = df.getFactAtLocation(l);
			int numArgs = cf.getNumArguments(ii, cpg);
			// If the function has 1 argument passed to it:
			// This should always be true since the methods in the list
			// only have one argument.
			if (numArgs == 1) {
				// Get the only constant value passed to the function
				Constant val = cf.getStackValue(0);
				
				// If the value is not a constant string
				// (I know it is a String because the methodsToWatch list specifies argument type)
				if (!val.isConstantString())
				{
					// Log and report
					BugInstance bug = new BugInstance(this, "POSSIBLE_COMMAND_INJECTION", HIGH_PRIORITY);
					bug.addClassAndMethod(mg, jc.getSourceFileName());
					bugAccumulator.accumulateBug(bug, SourceLineAnnotation.fromVisitedInstruction(cc, mg, jc.getSourceFileName(), l.getHandle()));
				}
			}
		}
		bugAccumulator.reportAccumulatedBugs();
	}

	public void report() {}
}
